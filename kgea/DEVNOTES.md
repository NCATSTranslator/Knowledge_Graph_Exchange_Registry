# Developers' Notes

This file complement both the ["Getting Started"](README.md) document which outlines KGE Archive ("Archive") deployment procedures and the [KGE Archive Roadmap](KGE_ARCHIVE_ROADMAP.md) document which outlines the details about the KGE Archive implementation components. Here, we document a few Archive development issues and recommended (required?) responses.

# OpenAPI Server Code Generation

After the initial flurry of Archive development, the OpenAPI 3 dependent web service code will unlikely need to be modified. However, if there is a need to change it, there are some special considerations.

## Non-Python Code Generation Dependencies

The Archive his project, once deployed, exposes OpenAPI 3 web services defined by the [KGE Archive Web Services OpenAPI 3 specification](./api/kgea_api.yaml).  Boilerplate web service code implementation of these services in the project is generated by the [OpenAPI Tools openapi-generator-cli](https://github.com/OpenAPITools/openapi-generator) code generator program.

Although the project itself is coded in Python, updating the Python code for the web services requires re-running the code generator, after any revisions to the API specification. This code generator is a Java software program. Thus, such a Java binary (release 8 or better) needs to be installed and available on the OS PATH (might not be on minimal operating systems). For a Debian Linux (e.g. Ubuntu), it may suffice to execute the following installation:

```shell
sudo apt install default-jre
```

If you are working on a Linux server, you may find the [bash launcher script](https://github.com/OpenAPITools/openapi-generator/blob/master/bin/utils/openapi-generator-cli.sh) useful to manage and launch the code generator.  A copy of this script (circa January 2021) is copied into the `scripts` subfolder of this project repository as a convenience. However, in addition to Java 8, the script has a few other dependencies:

1. [Maven dependency management tool](https://maven.apache.org/) (release 3.3.4 or better)
2.  `jq` program 
   
Again, assuming a Debian Linux OS (e.g. Ubuntu) build environment, it may suffice to execute the following installations:

```shell
sudo apt install maven
sudo apt install jq
```

Running the `openapi-generator-cli.sh` the first time downloads the required JAR file to the same directory as the script, thus when the script is rerun again, it performs all the expected operations. For example:

```shell
scripts/openapi-generator-cli.sh
#... lots of output showing the script execution
scripts/openapi-generator-cli.sh version
5.0.0
```

## Validating a modified API

Whenever a change is made to the project OpenAPI yaml file, it is a good idea to validate it against OpenAPI 3 expectations, as follows:

```shell
./scripts/openapi-generator-cli.sh validate -i ./kgea/api/kgea_api.yaml

```

## Generating Code

A custom project script [generate-kge-server.sh](../scripts/generate-kge-server.sh) calls a locally mirrored copy of the [OpenAPI Generator Script](../scripts/openapi-generator-cli.sh). Running the `openapi-generator-cli.sh` the first time downloads the required OpenAPI code generator JAR file to the same directory as the script. 

The output is something like:

```shell
./scripts/generate-kge-server.sh

Project name: kge-archive
Project description: NCATS_Knowledge_Graph_Exchange_Archive_Web_Services

Project source code: ./kgea
Target OpenAPI: ./kgea/api/kgea_api.yaml
Generated server code: ./kgea/server
Target version is: 0.0.1

Continue (yes/no - default 'no'): Yes

... lots of output

```

The code generator creates a basic README file under the [KGEA Server subdirectory](./server/README.md) which provides basic instructions about how to run the resulting server code, either from an OS terminal or within a Docker container.

## Reconnecting the Generator Code to the Project Logic

Rerunning the server code generation basically appears to rewrite most of the contents of the [KGEA Server subdirectory](./server) with a few notable exceptions such as:

- extra files added to the subdirectory by the developer, which are files not generated by the code generator, including files from previous runs which were not required to be generated by a new run (i.e. when specific parts - tags, operation ids, components - of the API were renamed or deleted)
  
- existing test files (under the [server/web_services test subdirectory](server/web_services/test)) which were modified by a developer after the original code generation.

- not sure what else (need to review...)

However, the code generation process pretty well overwrites every other file it knows about by name, with fresh code.

This basically means that it is advisable to separate custom handlers to every api controller method in a separate file, then insert delegation calls in the api controller method, perhaps mainly in the `return` statement of the generated method. Namely:

```python
from typing import List, Dict
from aiohttp import web

from web_services.models.attribute import Attribute
from web_services import util


async def access(request: web.Request, kg_name, session) -> web.Response:
    """Get KGE File Sets

    

    :param kg_name: Name label of KGE File Set, the knowledge graph for which data files are being accessed
    :type kg_name: str
    :param session: 
    :type session: str

    """
    return web.Response(status=200)
```

becomes something like:

```python
from ..kge_handlers import kge_access

async def access(request: web.Request, kg_name: str, session: str) -> web.Response:
    """Get KGE File Sets

    :param request:
    :type request: web.Request
    :param kg_name: Name label of KGE File Set, the knowledge graph for which data files are being accessed
    :type kg_name: str
    :param session: 
    :type session: str

    """
    return await kge_access(request, kg_name, session)
```

where `kge_access` is a handler method defined in the project developer defined Python module `kge_handlers`, assumed to be sitting alongside the generated api code in `provider_controller.py` (under the `web_services/controllers` package in the code generated `server` subdirectory of the KGE Archive project).

This code delegation needs to be repaired every time the code generator is run on the `kgea_api.yaml` specification.

In addition, `boto3 >= 1.17.0` may need be added back into the **web_services** `requirements.txt` file.

## Modifications to other autogenerated modules


### Python `setup.py` files

The `kgea/server/setup.py` and `kgea/server/web_services/__init__.py` module are also overwritten by code generation, losing some small revisions for AIOHTTP session management here, thus we have a master templates `kgea/server/setup-template.py` and `kgea/server/web_services/__init__-template.py` which can be used to restore the revised code (Note: perhaps carefully do diff the original code against the regenerated code just to check other revisions which may need to be kept)

### Generated `kgea/server/web_services/openapi/openapi.yaml`

In the generated OpenAPI file, the nature of the integrated KGE Archive application requires that the prefix `kgea.server.` needs to be added to all of the `web_services.*` controller package identifiers in the `x-openapi-router-controller` tags in the  `openapi.yaml` file. For example:

```yaml
x-openapi-router-controller: web_services.controllers.upload_controller
```

should read

```yaml
x-openapi-router-controller: kgea.server.web_services.controllers.upload_controller
```

### Documentation

The `kgea/server/README.md` should be manually corrected as follows:

1. Under **# Usage**, the startup instructions which read:


```
pip3 install -r requirements.txt
python3 -m web_services
```

should be revised to read


```
pip3 install -r requirements.txt
python3 -m kgea.services.web_services
```

again to align with the nature of the integrated Archive application.
